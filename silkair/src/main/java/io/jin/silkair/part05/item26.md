### **용어 정리**

1. **제네릭 클래스와 제네릭 인터페이스**
    - **제네릭 클래스**와 **제네릭 인터페이스**는 **타입 매개변수**를 사용하여 선언된 클래스를 의미
    → **제네릭 타입**이라고 부른다.
    - Ex) `List<E>`는 원소의 타입을 나타내는 타입 매개변수 `E`를 사용하는 제네릭 인터페이스이다. 보통 `List<String>`과 같이 구체적인 타입을 지정해 사용해.
2. **매개변수화 타입 (Parameterized Type)**
    - **매개변수화 타입**은 제네릭 타입에 **구체적인 타입 매개변수**를 지정해 만든 타입
    - Ex) `List<String>`은 **String 타입**의 원소를 가진 리스트를 나타내는 매개변수화 타입이다. 여기서 `String`이 실제 타입 매개변수
3. **로 타입 (Raw Type)**
    - **로 타입**은 **제네릭 타입의 타입 매개변수를 사용하지 않은** 상태의 타입
    - Ex) `List<E>`의 로 타입은 `List`인데, 이는 타입 매개변수 정보가 없어진 상태를 말한다. **제네릭 이전 코드와 호환하기 위해** 존재하지만, 안전하지 않다.

### **제네릭을 사용하지 않을 때의 문제점**

- **제네릭을 사용하지 않는 경우**, 타입 안전성이 보장되지 않는다.
    
    ```java
    private final Collection stamps = ...; // 제네릭 미사용
    ```
    
    - 이 코드는 Stamp 인스턴스만을 다룬다는 주석이 있지만, 컴파일러는 이를 인식하지 못한다. 그래서 다른 타입의 객체가 들어가도 컴파일 오류 없이 실행
- 실제로 잘못된 타입의 객체가 들어간다면, 해당 객체를 사용하려고 할 때 런타임 오류 발생
    
    ```java
    for (Iterator i = stamps.iterator(); i.hasNext(); ) {
        Stamp stamp = (Stamp) i.next(); // ClassCastException 발생 가능
        stamp.cancel();
    }
    ```
    
    - stamps에 잘못된 타입의 객체가 들어가 있으면, 해당 객체를 꺼낼 때 오류가 발생

### **제네릭을 사용하면 얻는 장점**

- 타입 안전성 확보
    
    ```java
    private final Collection<Stamp> stamps = ...; // 제네릭 사용
    ```
    
    - 제네릭을 사용해 선언하면, stamps에는 Stamp 타입만 담을 수 있다. → 컴파일 시점에 타입 오류를 바로 발견

### 로 타입(Raw Type)이란?

- 로 타입은 제네릭 타입에서 타입 매개변수를 사용하지 않은 상태의 타입을 의미
 Ex) `List<E>`는 제네릭 타입인데, 여기에 타입 매개변수를 주지 않고 `List`만 사용하는 경우가 로 타입

### 왜 로 타입을 사용하면 안 될까?

- 로 타입을 사용하면 타입 안전성을 잃게 된다.
    - 제네릭 타입을 사용하면 컴파일러가 타입을 체크해주고, 잘못된 타입이 들어가면 오류를 발생시키지만, 로 타입을 사용하면 이런 보호장치가 없다.
    Ex) `List<String>`을 사용하면 `String` 타입의 원소만 담을 수 있지만, `List` (로 타입)를 사용하면 `String`, `Integer`, `Object` 등 아무 타입이나 넣을 수 있다.

### 로 타입을 사용하면 어떤 문제가 생길까?

- 타입 안전성을 잃고, 런타임 오류(ClassCastException)가 발생할 가능성이 증가
    
    → 로 타입을 사용하면 컴파일러가 타입을 체크하지 않기 때문에, 프로그램이 실행되기 전까지 문제를 발견하지 못한다.
    예시
    
    ```java
    List list = new ArrayList(); // 로 타입 사용
    list.add("Hello");
    list.add(123); // 문제 없음
    
    String s = (String) list.get(1); // ClassCastException 발생
    ```
    
    → 이 코드에서는 리스트에 `Integer` 타입을 넣어도 오류가 발생하지 않지만, 나중에 `String`으로 형변환을 시도할 때 런타임 오류가 발생
    

### 로 타입 대신 사용하는 방법: 비한정적 와일드카드 타입

- 로 타입 대신 비한정적 와일드카드 타입(`?`)을 사용하는 것이 좋다.
Ex) `Set<?>`는 어떤 타입의 원소든 담을 수 있는 컬렉션을 의미
- 비한정적 와일드카드 타입을 사용하면 타입 안전성은 유지하면서, 로 타입이 가진 문제를 피할 수 있다
예시 :

```java
static int numElementsInCommon(Set<?> s1, Set<?> s2) {
    int result = 0;
    for (Object o1 : s1) {
        if (s2.contains(o1)) {
            result++;
        }
    }
    return result;
}
```

→ 로 타입 대신 비한정적 와일드카드 타입을 사용한 안전한 코드

### 로 타입을 써도 괜찮은 예외 상황

1. `Class` 리터럴
    - 자바에서는 `List<String>.class` 같은 매개변수화된 타입의 `Class` 리터럴을 허용하지 X.
    → `List.class`처럼 로 타입을 사용
2. `instanceof` 연산자
    - 런타임에는 제네릭 타입 정보가 사라지기 때문에, `instanceof`를 사용할 때 매개변수화된 타입을 사용할 수 없다.
    → `Set<?>` 대신 `Set`을 사용

```java
if (obj instanceof Set) {
    Set<?> s = (Set<?>) obj; // 안전한 형변환
}
```