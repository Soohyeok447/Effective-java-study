### 가변인수(varargs)란?

가변인수는 메서드에 여러 개의 인수를 한꺼번에 넘길 수 있게 해주는 기능이다. 인수 개수를 미리 정해두지 않고, 호출할 때 몇 개든 넘길 수 있다. 예를 들어, 친구들 이름을 여러 개 넣고 싶으면 이렇게 할 수 있다:

```java
ublic void 친구들(String... 이름들) {
    for (String 이름 : 이름들) {
        System.out.println(이름);
    }
}

친구들("철수", "영희", "민수");
```

이렇게 하면 `철수`, `영희`, `민수`가 출력된다. `...`는 가변인수를 나타내는 표시이다.

### 제네릭이란?

제네릭은 여러 타입을 받을 수 있도록 해주는 기능이야. 리스트 안에 숫자를 넣거나 문자열을 넣고 싶으면, 제네릭을 사용해서 리스트가 숫자를 받을지, 문자열을 받을지 결정할 수 있다:

```java
List<String> 문자열리스트 = new ArrayList<>();
List<Integer> 숫자리스트 = new ArrayList<>();
```

이렇게 하면 문자열 리스트와 숫자 리스트를 따로 만들 수 있다.

### 제네릭과 가변인수를 함께 쓰면?

여기서 문제가 생기는데, 제네릭과 가변인수를 함께 사용하면 안전하지 않을 때가 있다. 제네릭을 쓰는 가변인수 메서드를 만들 때, 컴파일러가 타입 오류를 놓칠 수 있다. 그 결과, 프로그램이 실행될 때 잘못된 타입 때문에 오류(ClassCastException)가 발생할 수 있다.

### 예시: 위험한 가변인수와 제네릭

```java
static void 위험한메서드(List<String>... 리스트들) {
    List<Integer> 숫자리스트 = List.of(42);
    Object[] 객체배열 = 리스트들;
    객체배열[0] = 숫자리스트;  // 위험한 코드!
    String 문자열 = 리스트들[0].get(0);  // 여기서 오류가 발생할 수 있어!
}
```

위 코드는 리스트에 숫자 리스트를 넣고 다시 문자열로 꺼내려고 한다. 하지만 이건 안전하지 않아서 오류가 발생할 수 있다! 컴파일러는 이걸 미리 잡지 못하고, 실행 중에 오류가 날 수 있다.

### 그럼 왜 허용할까?

사실 가변인수 메서드는 실무에서 아주 유용하다. 그래서 자바에서는 이 문제를 완전히 막지 않고 경고만 주는 방법을 선택했다.

### 안전한 가변인수 메서드를 만드는 방법

이 문제를 해결하려면, 가변인수 배열에 값을 저장하지 않거나, 배열을 외부에 노출하지 않는 방법을 사용해야 한다. 그리고 안전한 메서드임을 보장할 때는 @SafeVarargs라는 애너테이션을 사용할 수 있다.

안전한 가변인수 메서드

```java
SafeVarargs
static <T> List<T> 안전한메서드(List<? extends T>... 리스트들) {
    List<T> 결과 = new ArrayList<>();
    for (List<? extends T> 리스트 : 리스트들) {
        결과.addAll(리스트);
    }
    return 결과;
}
```

### 다른 해결 방법

가변인수 대신 리스트(List)를 사용할 수도 있다. 이렇게 하면 안전하게 제네릭을 사용할 수 있고, 컴파일러가 자동으로 타입 안전성을 확인해준다.

```java
static <T> List<T> 안전한리스트메서드(List<List<? extends T>> 리스트들) {
    List<T> 결과 = new ArrayList<>();
    for (List<? extends T> 리스트 : 리스트들) {
        결과.addAll(리스트);
    }
    return 결과;
}
```

이 방법은 코드가 조금 더 안전하고 깔끔하지만, 가변인수보다는 사용하기 조금 불편할 수 있다.