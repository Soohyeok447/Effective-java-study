### 와일드카드 타입이란?

와일드카드 타입은 더 유연하게 만들고 싶을 때 사용한다.

- `<? extends T>`는 어떤 타입이든 T의 자식들을 받을 수 있다는 뜻이야. 즉, `List<? extends Fruit>`는 사과 리스트나 바나나 리스트 모두를 받을 수 있다!

### 예시: Stack 클래스

이제 예시를 보자. 우리가 Stack(스택)이라는 상자를 만들었다고 해보자. 이 상자는 숫자들만 넣을 수 있는 상자이다. 그런데 우리가 정수(Integer)도 넣고 싶다면 어떻게 해야 할까?

처음에 우리가 이렇게 만들었다고 해보자:

```java
public void pushAll(Iterable<E> src) {
    for (E e : src) {
        push(e);
    }
}
```

이 메서드는 E 타입의 값들만 받을 수 있다. 그래서 숫자(Stack<Number>) 상자에는 정수(Integer) 상자를 넣을 수 없다! (정수(Integer)는 숫자(Number)의 하위 타입이기 때문)

그래서 와일드카드 타입을 사용해서 이렇게 수정할 수 있다:

```java
public void pushAll(Iterable<? extends E> src) {
    for (E e : src) {
        push(e);
    }
}
```

이제 어떤 타입의 값이든 넣을 수 있게 됐다. 정수 리스트도, 숫자 리스트도 모두 넣을 수 있다!

### PECS 규칙

여기서 중요한 규칙이 있다. 바로 PECS 규칙이다!

- Producer-extends: 값을 생산하는 쪽에서는 `<? extends T>`를 사용
    - 예: 스택에 값을 넣을 때는 `<? extends T>`를 사용
- Consumer-super: 값을 소비하는 쪽에서는 `<? super T>`를 사용
    - 예: 스택에서 값을 꺼낼 때는 `<? super T>`를 사용

이 규칙만 기억하면 언제 와일드카드를 써야 할지 쉽게 알 수 있다.

예시: popAll 메서드

이번엔 스택에서 값을 꺼내는 메서드를 만들자. 처음에 이렇게 만들었다:

```java
public void popAll(Collection<E> dst) {
    while (!isEmpty()) {
        dst.add(pop());
    }
}

```

하지만 이렇게 하면 숫자 스택에서 객체 컬렉션으로 값을 옮길 수 없다. 그래서 우리는 와일드카드 타입을 사용해서 수정할 것이다:

```java
public void popAll(Collection<? super E> dst) {
    while (!isEmpty()) {
        dst.add(pop());
    }
}

```

→ 이제 객체 컬렉션도 받을 수 있다!

### swap 메서드란?

우리는 이제 swap이라는 메서드를 고려할 수 있다. 이 메서드는 리스트 안에 있는 두 개의 아이템의 자리를 바꾸는 역할을 한다. 1번 인덱스와 2번 인덱스에 있는 아이템들을 교환하는 것이다.

### 타입 매개변수 vs. 와일드카드

이 작업을 할 때, 우리는 두 가지 방법으로 swap 메서드를 만들 수 있다

- 타입 매개변수를 사용한 방법
- 와일드카드를 사용한 방법

### (1) 타입 매개변수를 사용한 방법

```java
public static <E> void swap(List<E> list, int i, int j);
```

여기서 `<E>`는 타입 매개변수이다. 즉, 우리가 어떤 타입의 리스트를 받든, E라는 타입을 통해 그 리스트 안의 타입을 명확히 지정할 수 있다. 그래서 E 타입을 사용해서 교환할 수 있는 것이다.

### (2) 와일드카드를 사용한 방법

```java
public static void swap(List<?> list, int i, int j);
```

여기서 `<?>`는 와일드카드다. 와일드카드는 "이 리스트 안에 어떤 타입이든 올 수 있다"라는 뜻이다. 즉, `<?>`는 모든 타입을 받을 수 있고, 그래서 리스트에 어떤 타입의 원소가 있든 교환할 수 있는 것.

### 어느 방법이 더 나을까?

public API라면, 와일드카드를 사용하는 두 번째 방법이 더 좋다. 왜냐하면 타입 매개변수 없이도, 모든 타입의 리스트를 받을 수 있기 때문이다. 즉, 메서드를 더 간단하게 만들 수 있다.

### 와일드카드 방식의 문제점

하지만 와일드카드를 사용할 때 문제가 생길 수 있어. 우리가 리스트의 두 원소를 교환하려고 이렇게 작성했다고 해보자.

```java
list.set(i, list.set(j, list.get(i)));
```

이 코드를 컴파일하면 오류가 발생한다. 왜냐하면 와일드카드 타입인 `List<?>`는 정확한 타입을 알 수 없기 때문이다. 즉, 리스트에서 어떤 값을 꺼내도 타입이 무엇인지 확실히 알 수 없어서 다시 리스트에 넣을 수 없다는 것이다.

### 해결 방법: 도우미 메서드 사용하기

이 문제를 해결하려면, 도우미 메서드를 사용해야 한다. 도우미 메서드는 와일드카드 타입을 실제 타입으로 변환해주는 역할을 한다. 즉, 도우미 메서드를 사용하면 우리가 리스트의 실제 타입을 알 수 있어, 그래서 타입 안전성을 지킬 수 있다.

메서드 도우미의 예시

```java
public static void swap(List<?> list, int i, int j) {
    swapHelper(list, i, j);
}

private static <E> void swapHelper(List<E> list, int i, int j) {
    list.set(i, list.set(j, list.get(i)));
}
```

여기서 `swapHelper` 메서드는 제네릭 메서드이다. 즉, 이 메서드는 리스트의 정확한 타입을 알고 있어서 교환 작업을 안전하게 할 수 있다는 것이다. 이 방식 덕분에, 우리는 와일드카드를 사용해서도 안전하게 리스트의 원소들을 교환할 수 있다.