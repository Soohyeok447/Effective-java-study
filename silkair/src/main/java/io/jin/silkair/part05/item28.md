### 배열과 제네릭의 차이점

### 차이점 1: 배열은 공변, 제네릭은 불공변

- 배열은 공변
    
    예를 들어 `Long[]` 배열이 있다면, 이 배열을 `Object[]` 배열로 바꿀 수 있다는 것. 즉, 배열의 타입이 함께 변할 수 있다는 뜻이다. `Long` 타입이 `Object` 타입의 하위 타입이니까, `Long[]`도 `Object[]`의 하위 타입이 되는 것이다.
    
- 하지만, **제네릭 타입은 불공변(invariant)
    
    서로 다른 제네릭 타입끼리는 서로 아무 관계가 없다는 뜻. 예를 들어 `List<Long>`은 `List<Object>`의 하위 타입이 아니고 상위 타입도 아니다.
    

### 차이점 2: 배열은 실체화, 제네릭은 소거

- 배열은 실체화된다.
    
     배열이 런타임에도 자신이 어떤 타입의 데이터를 담고 있는지 알고 있다는 뜻. 그래서 만약 `Long[]` 배열에 `String` 값을 넣으려고 하면, 바로 오류가 나온다.
    
- 제네릭은 소거된다.
    
    런타임에는 제네릭 타입 정보가 사라진다는 뜻. 즉, 제네릭은 컴파일할 때만 타입을 확인하고, 실제 프로그램이 실행되는 동안에는 타입 정보를 잃어버린다. (이렇게 하는 이유는 예전 버전의 자바 코드와 호환되기 위해서). 제네릭이 등장하기 전의 코드와도 잘 작동하게 만들기 위해서!!
    

### 배열과 제네릭의 충돌

이 두 가지 차이점 때문에, 배열과 제네릭은 잘 어울리지 못한다. 제네릭 배열을 만들려고 하면 컴파일 오류가 발생!

```java
new List<E>[];       // 오류
new List<String>[];  // 오류
new E[];             // 오류
```

제네릭 배열을 만들 수 없는 이유는, 제네릭의 타입 정보가 런타임에 사라지기 때문이다. 배열은 자신의 타입을 알아야만 동작할 수 있어서 제네릭과 함께 사용하기가 어렵다.

- 더 쉬운 설명
    
    ### 배열과 제네릭이 뭘까?
    
    - 배열은 여러 개의 같은 종류의 물건을 줄지어 놓은 것처럼, 하나의 타입(종류)으로 된 여러 개의 값을 모아 놓은 것. 예를 들어, `사과[]` 배열은 사과들만 쭉 나열해 놓은 거라고 생각하면 된다.
    - 제네릭은 뭔가를 담을 때 타입(종류)을 미리 정해주는 상자라고 생각하면 된다. 예를 들어, 사과 상자(List<사과>)는 사과만 넣을 수 있는 것이다. 이 상자에는 다른 과일, 예를 들어 바나나를 넣을 수 없다.
    
    ### 배열과 제네릭의 차이점
    
    ### 차이점 1: 배열은 "타입이 변할 수 있다"
    
    - 배열은 타입을 좀 더 자유롭게 바꿀 수 있다. 예를 들어, 사과 배열은 과일 배열이 될 수 있다. 왜냐하면 사과도 과일의 한 종류니까. 과일[] 안에 사과가 들어갈 수 있는 것처럼 배열은 타입을 변하게 할 수 있다. 이렇게 타입이 서로 바뀔 수 있는 것을 공변이라고 한다.
    
    ### 차이점 2: 제네릭은 "타입이 절대 변하지 않는다"
    
    - 제네릭은 타입이 변하지 않는다. 사과 상자에는 사과만 넣을 수 있고, 과일 상자에는 여러 종류의 과일을 넣을 수 있지만, 사과 상자를 과일 상자로 바꿀 수는 없다. 제네릭은 서로 다른 타입끼리는 절대 바뀔 수 없어서 안전!!
    
    ### 배열과 제네릭이 함께 쓰이기 어려운 이유
    
    - 배열은 내가 무슨 타입인지 알고 있어야 한다. 그래서 만약 사과 배열에 바나나를 넣으려고 하면 바로 에러가 발생.
    - 제네릭은 내가 무슨 타입인지 모른다. 제네릭은 컴퓨터가 코드를 실행하기 전에만 타입을 확인하고, 실행할 때는 타입을 잊어버리기 때문!
    
    이런 차이 때문에 배열과 제네릭을 함께 쓰기 어렵고, 제네릭 배열은 만들 수 없다. 사과 상자의 배열(List<사과>[] 같은 것)은 만들 수 없다.
    

### 제네릭 배열을 만들 수 없는 이유

제네릭 배열을 만들 수 없도록 한 이유 : 안전하지 않다.
만약 우리가 어떤 타입의 제네릭 배열을 만들고 그 배열에 다른 타입의 데이터를 넣어버린다면 컴파일러가 오류를 잡아주지 못하고, 프로그램이 실행될 때야 비로소 오류가 발생!! → 이런 문제를 방지하기 위해 제네릭 배열을 만드는 것을 막아 놓았다.

### 예시

1. `List<String>[] stringLists = new List<String>[1];` 
제네릭 배열을 만들었다고 가정해보자. 여기서 `List<String>` 타입의 배열을 생성했다. 이 배열은 문자열만 담은 리스트만 들어갈 수 있다.
2. `Object[] objects = stringLists;` 이 코드는 위의 `List<String>` 배열을 `Object` 배열로 바꾼 것이다. 이 과정에서는 문제가 없다. 왜냐하면 배열은 서로 관련이 있는 타입끼리는 변환이 가능하기 때문.
3. `objects[0] = List.of(42);` 여기서 문제가 발생!
`Object` 배열의 첫 번째 자리에 `List<Integer>`를 넣었다. 원래는 `List<String>`만 들어가야 하는 자리인데, 컴파일러는 이를 허용한다.
4. 마지막으로 `String s = stringLists[0].get(0);` 이렇게 첫 번째 리스트에서 문자열을 꺼내려고 했는데, 사실 그 안에는 숫자(`Integer`)가 들어 있었다! 이러면 프로그램이 실행 중에 오류를 내며 멈춰버린다.

이런 위험한 상황을 막기 위해서 제네릭 배열을 만들 수 없게 해 놓은 것!

### 비검사 경고 해결법

배열 대신에 리스트(List)를 사용하면 경고 없이 안전하게 코드를 작성할 수 있다. 예를 들어, 제네릭을 사용하는 `Chooser` 클래스를 생각해보자.

- 원래 배열을 사용해서 만들면 컴파일 경고가 뜨고 안전하지 않다.
- 대신, 배열을 리스트로 바꾸면 코드가 약간 길어질 수 있지만 타입 검사도 확실해지고 런타임 오류도 줄어든다.

- Chooser 클래스 설명!
    
    `Chooser` 클래스는 여러 가지 선택지 중에서 하나를 무작위로 골라주는 역할을 하는 클래스이다.
    여러 가지 과자 중에서 하나를 골라주거나, 게임에서 주사위를 굴려서 숫자를 무작위로 선택하는 데 사용 가능
    
    ### Chooser 클래스의 구조
    
    1. **생성자(Constructor)**: `Chooser` 클래스는 생성자를 통해 선택지 목록을 받는다. 이 목록은 `Collection<T>` 타입으로, 다양한 종류의 컬렉션(예: `List`, `Set` 등)을 받을 수 있다. 이때, `<T>`는 제네릭 타입 매개변수로, 선택할 항목의 타입을 의미한다.
    `Chooser<String>`은 문자열을 선택하고, `Chooser<Integer>`는 숫자를 선택할 수 있다는 뜻
    2. **choose 메서드**: 이 메서드는 리스트에서 무작위로 하나의 항목을 선택해서 반환한다. 내부적으로 `ThreadLocalRandom.current()`를 사용해서 무작위 인덱스를 생성하고, 그 인덱스에 해당하는 항목을 반환하는 방식.
    
    ### 제네릭을 사용한 Chooser
    
    제네릭을 사용하면 `Chooser` 클래스가 특정 타입만 선택할 수 있도록 강제할 수 있다. 이렇게 하면 `Chooser`가 타입 안전성을 갖추고, 컴파일할 때 타입 오류를 잡아줄 수 있다.
    
    ### 예시
    
    제네릭을 사용한 `Chooser` 클래스의 코드 예시:
    
    ```java
    import java.util.*;
    
    public class Chooser<T> {
        private final List<T> choiceList;
    
        // 생성자: 선택지 리스트를 받아서 초기화한다.
        public Chooser(Collection<T> choices) {
            choiceList = new ArrayList<>(choices);
        }
    
        // 무작위로 선택지를 하나 반환하는 메서드
        public T choose() {
            Random rnd = ThreadLocalRandom.current();
            return choiceList.get(rnd.nextInt(choiceList.size()));
        }
    }
    ```
    
    ### 사용 예시
    
    ```java
    public class Main {
        public static void main(String[] args) {
            List<String> fruits = Arrays.asList("Apple", "Banana", "Cherry");
            Chooser<String> fruitChooser = new Chooser<>(fruits);
    
            System.out.println("Randomly chosen fruit: " + fruitChooser.choose());
        }
    }
    ```
    
    이 예제에서는 과일 목록에서 무작위로 하나를 선택해서 출력하는 코드이다. `Chooser` 클래스는 생성자에서 받은 과일 리스트 중 하나를 무작위로 골라 반환한다.
    
    이렇게 `Chooser` 클래스는 다양한 타입의 데이터를 다룰 수 있도록 제네릭을 사용해서 안전하고 유연하게 설계된 클래스이다.