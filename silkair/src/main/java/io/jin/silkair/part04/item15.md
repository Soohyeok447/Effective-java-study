**캡슐화(정보 은닉)를 통해 내부 구현을 숨기고, 시스템의 유연성, 성능 최적화, 재사용성, 그리고 디버깅의 용이성을 높이자.**

### 1. 캡슐화(정보 은닉)의 장점

- 병렬 개발 가능: 서로의 내부 구현에 신경 쓰지 않으므로, 여러 컴포넌트를 동시에 개발할 수 있다.
- 디버깅과 유지 보수: 각 컴포넌트를 쉽게 이해하고, 다른 컴포넌트로 교체하기 쉬워서 유지 보수가 간편하다.
- 성능 최적화: 성능을 개선해야 할 때, 특정 컴포넌트만 최적화할 수 있다.
- 재사용성 증가: 외부 의존성이 없는 독립적인 컴포넌트는 여러 상황에서 쉽게 재사용될 수 있다.
- 시스템 제작 난이도 감소: 시스템 전체가 완성되기 전에도 개별 컴포넌트의 동작을 검증할 수 있어서, 큰 시스템을 더 쉽게 제작할 수 있다.

### 2. 접근 제한자를 활용한 정보 은닉

접근 제한자를 통해 내부 구현을 외부에 드러내지 않는 것이 중요하다. 이를 통해 구현과 API를 분리할 수 있다.

- `private`: 해당 클래스 안에서만 접근 가능.
- `package-private`: 같은 패키지 내의 클래스에서 접근 가능 (접근 제한자를 명시하지 않았을 때 기본 적용됨).
- `protected`: 같은 패키지와, 상속받은 하위 클래스에서 접근 가능.
- `public`: 모든 곳에서 접근 가능.

> Tip: 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다. 공개할 필요가 없는 멤버는 private로, 같은 패키지에서만 접근이 필요하다면 package-private으로, 상속이 필요할 경우에는 protected로 지정하자.
> 

### 3. 클래스 멤버의 접근성을 최소화하는 방법

- 공개 API 외의 멤버는 모두 `private`로 선언하고, 패키지 내 다른 클래스에서 접근해야 하는 멤버만 `package-private`로 지정
- 테스트를 위해 멤버를 공개하지 말아야 한다. 테스트용으로 API를 공개하면 유지보수 비용이 증가
- `public` 클래스의 인스턴스 필드는 가급적 `public`으로 선언 X. 필드에 가변 객체를 담으면 불변성을 보장할 수 없고, 스레드 안정성 문제도 발생할 수 있다.

### 4. 상수와 배열 처리

- `public static final` 상수는 불변 객체나 기본 타입을 참조할 때만 사용.
- 배열은 길이가 0이 아닌 이상 변경 가능하므로, `public static final`로 배열을 선언하거나, 배열을 반환하는 메서드를 제공하면 안된다.
    - 대신, **불변 리스트**로 제공하거나, **방어적 복사**를 사용해 배열을 복사한 뒤 반환하는 방식으로 처리