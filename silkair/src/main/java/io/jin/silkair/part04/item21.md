### 디폴트 메서드의 등장

Java 8에서 디폴트 메서드가 추가되기 전에는 인터페이스에 메서드를 추가하면 기존 구현체들을 깨뜨릴 위험이 있었다. 하지만 디폴트 메서드가 생기면서 기존 구현체를 수정하지 않고도 새로운 메서드를 인터페이스에 추가할 수 있게 되었다. 예를 들어 `removeIf()` 메서드는 Java 8에서 `Collection` 인터페이스에 추가된 메서드이다.

### 디폴트 메서드의 위험성

디폴트 메서드 덕분에 기존 인터페이스를 수정할 수 있는 유연성이 생겼지만, 모든 문제를 해결한 것은 아니다. 디폴트 메서드를 추가할 때도 기존 구현체와 완벽하게 호환될 것이라고 보장할 수 없기 때문이다.

Ex) `Collection` 인터페이스에 추가된 `removeIf()` 메서드

```java
default boolean removeIf(Predicate<? super E> filter) {
    Objects.requireNonNull(filter);
    boolean removed = false;
    final Iterator<E> each = iterator();
    while (each.hasNext()) {
        if (filter.test(each.next())) {
            each.remove();
            removed = true;
        }
    }
    return removed;
}
```

이 메서드는 `Predicate` 조건에 맞는 요소들을 제거하는 메서드로, 기본적인 동작을 제공한다. Apache Commons Collections의 SynchronizedCollection은 스레드 안전성을 위해 모든 메서드 호출을 동기화(lock)하는데, 디폴트 메서드는 이걸 고려하지 않는다. 이전 버전에서는 `removeIf`가 재정의되지 않았기 때문에, 기본 동작이 적용돼 스레드 안전성이 깨질 수 있다

```java
public boolean removeIf(Predicate<? super E> filter) {
    synchronized(this.lock) {
        return this.decorated().removeIf(filter);
    }
}
```

위 코드는 동기화가 필요한 경우 `removeIf()`를 재정의한 예시이다. 그렇지 않으면 여러 스레드에서 사용 시 ConcurrentModificationException이나 예상치 못한 결과가 발생할 수 있다.

### 디폴트 메서드 추가의 주의점

1. 기존 구현체와 호환성: 디폴트 메서드를 추가하면, 기존의 모든 구현체들이 자동으로 그 메서드를 가지게 된다. 하지만 구현체들이 그 메서드를 재정의하지 않으면 디폴트 메서드의 동작을 따르게 되는데, 이때 기존의 불변식이나 스레드 안전성이 깨질 수 있다.
2. 런타임 오류 가능성: 디폴트 메서드를 추가했을 때, 컴파일은 성공하더라도 런타임 오류가 발생할 가능성이 있다. 위에서 본 동기화 문제처럼, 디폴트 메서드가 기존의 동작과 잘 맞지 않으면 예상치 못한 문제가 발생!

### 디폴트 메서드를 신중하게 사용해야 하는 이유

디폴트 메서드는 기존 인터페이스에 메서드를 추가할 때 위험 요소를 내포하고 있다. 그렇기 때문에 필수적이지 않다면 디폴트 메서드로 기존 메서드를 추가하는 것은 피해야 한다.

### 새로운 인터페이스 설계 시 디폴트 메서드의 장점

새로운 인터페이스를 설계할 때는 디폴트 메서드를 적극 활용할 수 있다. 하지만, 디폴트 메서드를 인터페이스에서 메서드를 제거하거나 시그니처를 수정하는 용도로 사용해서는 안된다. 디폴트 메서드는 어디까지나 추가적인 유연성을 제공하기 위한 도구!

### 디폴트 메서드가 있어도 여전히 주의해야 할 점

디폴트 메서드 덕분에 인터페이스를 수정할 수 있는 유연성이 생기긴 했지만, 여전히 신중하게 설계해야 한다. 처음부터 신중하게 설계하자