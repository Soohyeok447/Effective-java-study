# item19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

item 18처럼 모르고 상위 클래스를 상속한 하위 클래스가 갑자기 오동작할 수 있기 때문에 상속은 위험함

### 상속 설계 & 문서화 지침

상속을 허용하기로 결정했으면 문서화가 잘 되어있어야 함

-   메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리해서 문서로 남겨야 함
    -   재정의 가능한 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 함
-   재정의 가능이란 public과 protected 메서드 중 final이 아닌 모든 메서드를 뜻함
-   **재정의 가능 메서드를 호출할 수 있는 모든 상황을 상세히 문서로 남겨야 함**
-   백그라운드 스레드나 정적 초기화 과정에서도 호출이 일어날 수 있음

### Javadoc의 @implSpec 태그

-   메서드의 내부 동작 방식을 명시하는 곳
-   메서드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성해줌
-   이를 통해 이 클래스를 상속해서 개발하는 하위 클래스 개발자는 이 메서드를 overriding할 때 동작을 예측가능함

### 상속을 염두에 둔 테스트를 진행하라

상속용 클래스를 검증하는 유일한 방법은 직접 하위 클래스를 만들어보는 것입니다. 최소 3개 이상의 다양한 하위 클래스를 만들어보며 클래스의 protected 멤버들이 충분한지, 혹은 너무 과하지는 않은지 테스트해야 합니다.

### 생성자는 재정의 가능 메서드를 호출하면 안 된다.

이것은 매우 중요한 규칙입니다. 상위 클래스의 생성자는 하위 클래스의 생성자보다 먼저 실행됩니다.

만약 상위 클래스 생성자가 재정의된 메서드를 호출하면, 그 메서드는 하위 클래스에서 재정의한 버전이 호출됩니다. 하지만 이때 하위 클래스의 생성자는 아직 실행 전이므로, 하위 클래스의 필드들이 초기화되지 않은 상태에서 메서드가 호출되어 심각한 오류(e.g., NullPointerException)를 일으킬 수 있습니다.

### 상속용으로 설계하려면 제약이 상당하다

까다로운 규칙들을 모두 지킬 자신이 없으면 상속을 금지하는 것이 훨씬 안전함

### 상속을 금지하는 방법

-   클래스를 final로 선언 (쉽고 확실한 방법)
-   모든 생성자를 private이나 package-private으로 선언하고, 정적 팩터리 메서드를 제공

### 정리

-   상속용 클래스를 설계하기란 만만치 않음
-   만약 상속용으로 클래스를 설계하려면 클래스 내부에서 스스로를 어떻게 쓰는지 모두 문서화 해야함
-   문서화한 것은 클래스를 쓰이는 한 반드시 지켜야 함 (안지키면 오동작 가능성 급증)
-   처음부터 상속을 금지하는게 모두에게 이로울지도...
-   먼저 컴포지션을 고려해보자
