## 7. 다 쓴 객체 참조를 해제하라

자바에는 가비지 컬렉터가 있지만, 그래도 메모리 누수가 발생할 수 있다.

더 이상 필요 없는 객체를 참조하는 변수가 남아 있을 때, 이런 참조를 쓸모없는 참조(obsolete reference)라고 부른다.

쓸모없는 참조가 남아 있으면 가비지 컬렉터가 객체를 회수하지 못하고, 메모리 사용량이 점점 늘어난다.

```java
public class Stack {
    private Object[] elements;
    private int size = 0;

    public Object pop() {
        if (size == 0) throw new EmptyStackException();
        return elements[--size]; // 문제: 참조 해제 없음
    }
}
```

위 코드에서 pop() 메서드는 스택에서 요소를 꺼내지만, 배열 안의 참조를 그대로 둔다.

스택이 줄어든 뒤에도 배열의 뒷부분에는 여전히 객체에 대한 참조가 남아 있음.

이 참조들은 더 이상 사용되지 않지만, 가비지 컬렉터는 이 사실을 알 수 없어서 결국 쓸모없는 객체들이 메모리에 계속 남아 있게 된다.

→ **명시적으로 참조 해제 필요**

```java
public Object pop() {
    if (size == 0) throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null; // 참조 해제
    return result;
}
```

요소를 꺼내고 나면 배열의 해당 위치를`null`로 바꿔서 참조를 끊는다.

이렇게 하면 가비지 컬렉터가 더 이상 쓰이지 않는 객체를 제대로 회수할 수 있다.

### **메모리 누수가 자주 발생하는 상황**

1. **직접 메모리를 관리하는 클래스**
    - 배열, 리스트 등 내부적으로 객체를 저장하고 관리하는 클래스는 요소를 제거할 때 참조를 반드시`null`로 해제해야 한다.
    - 예: 커스텀 캐시, 풀(pool) 구현 등.
2. **캐시**
    - 캐시에 객체를 넣고 제거하지 않으면 계속 남는다.
    - 해결 방법:
        - `WeakHashMap`을 사용해서 키가 더 이상 외부에서 참조되지 않으면 자동으로 엔트리를 제거한다.
        - 주기적으로 캐시를 정리한다(예: 백그라운드 스레드,`ScheduledThreadPoolExecutor`등).
3. **리스너와 콜백**
    - 리스너나 콜백을 등록만 하고 해제하지 않으면 계속 쌓인다.
    - 해결 방법: 약한 참조(`WeakReference`)로 저장한다.

### **일반적인 원칙**

- 참조를 명시적으로 해제하는 것은 예외적인 경우다. 대부분의 경우, **변수를 가능한 좁은 범위로 선언**하면 스코프를 벗어나면서 자동으로 참조가 해제된다.
- 메모리 누수는 눈에 잘 띄지 않으므로, **힙 프로파일러 같은 도구**로 주기적으로 점검하는 것이 좋다.
- 객체의 **생명주기를 명확히 파악**하고, 더 이**상 필요 없는 참조는 즉시 해제하는 습관**이 중요하다.

### **기타 팁**

- 지역 변수는 스코프가 끝나면 참조가 자동으로 해제된다.
- 캐시는`LinkedHashMap.removeEldestEntry()`같은 메서드를 활용해서 오래된 엔트리를 자동으로 제거할 수 있다.
- 약한 참조(`WeakReference`,`SoftReference`)를 적절히 활용하면 불필요한 객체가 오래 남는 것을 막을 수 있다.