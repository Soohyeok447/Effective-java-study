## 28. 배열보다는 리스트를 사용하라
### 요약 정리

- **배열:** "Animal[]에 Dog[] 넣기 가능 → 위험, 타입 정보가 살아 있으니 잘못 넣으면 실행중 터진다."

  런타임에서야 잘못된 타입 넣으면 에러, 실전에서 위험!

- **리스트:** "List<Dog>와 List<Animal>은 아예 별개 → 컴파일 단계에서 오류, 실행중 타입 정보는 없다."

  타입체크를 강하게 하니까 애초에 코딩 단계에서 막아준다. 훨씬 안전!


- 배열과 리스트를 혼용하지 말고 리스트를 우선 사용하자
- 리스트를 쓰면 타입 에러를 컴파일 단계에서 막을 수 있다
- 배열이 꼭 필요한 특수 상황(성능상 인덱스 접근 / 최저단 자료구조 등) 외에는 List<>가 디폴트

### 1. 배열은 공변(covariant)이다

공변성은 **타입 상속 관계가 배열에도 같이 적용된다**는 뜻이다!!

- 예시:

    ```java
    class Animal {}
    class Dog extends Animal {}
    
    Dog[] dogs = new Dog[2];
    Animal[] animals = dogs; // 배열은 공변성이라 업캐스팅 가능
    ```

- 단점: 상위 타입 배열(Animal[])에 하위 타입 배열(Dog[])을 넣었을 때

    ```java
    animals[0] = new Animal(); // 컴파일 성공, 런타임 ArrayStoreException 발생!
    ```

  실제 내부는 Dog[]인데 Animal을 넣으니 타입이 깨져서 런타임 에러가 발생한다.


### 2. 배열은 실체화(reified)된다

**런타임에도 배열 타입 정보(예: Dog[], Animal[], String[])가 남아있다.**

- 타입을 속여서 집어넣으면 실행중 에러가 난다.
- 타입 정보가 직접 남아 있음.

---

### 3. 제네릭 리스트(List<T>)는 불공변(invariant)이고 소거(erased)된다

**불공변**이란, 타입 간 상속 관계가 리스트에는 적용되지 않는다는 것.

- 예시:

    ```java
    List<Dog> dogList = new ArrayList<>();
    List<Animal> animalList = dogList; // 컴파일 에러! 불공변
    ```

- 서로 완전히 다른 타입으로 취급함.

**소거**란, 컴파일 시에는 List<String>처럼 타입을 알고 있지만

- 실제 실행(runtime)에서는 타입 정보가 사라져 그냥 List로 동작한다.
- 강제로(잘못해서) 이상한 타입을 넣으면 컴파일에서 잡아주고 런타임에서는 체크를 안 한다.