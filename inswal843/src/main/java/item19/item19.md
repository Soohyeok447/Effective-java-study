## Item 19: 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

상속용으로 설계되지 않은 일반 클래스를 상속하는 것은 매우 위험하다. 상위 클래스의 내부 구현에 의존하게 되어 상위 클래스가 변경될 때 하위 클래스가 오작동할 수 있기 때문이다.

---

### 1. 상속용 클래스 설계

상속용 클래스는 **내부 구현의 일부를 API 형태로 공개**해야 하므로 캡슐화가 깨질 수 있다. 클래스를 안전하게 상속할 수 있도록 만들려면 내부 동작 방식을 문서에 명확히 기술하고 그 약속을 지켜야 한다.

**문제:** 상위 클래스의 메서드가 재정의 가능한(overridable) 다른 메서드를 호출할 경우, 하위 클래스에서 그 메서드를 재정의하면 예상치 못한 동작을 할 수 있다.

---

### 2. 안전한 상속용 클래스를 만드는 방법

1. **내부 동작 방식을 문서로 남겨라.**
    - 클래스의 **javadoc**에 메서드가 내부적으로 어떤 다른 재정의 가능한 메서드를 사용하는지, 어떤 순서로 호출하는지 등을 명확히 기술해야 한다. **`@implSpec`** 태그를 사용하면 된다.
2. **상속용으로 설계한 클래스는 배포전에 하위 클래스를 만들어 검증해야 한다.**
    - 문서화한 내부 사용 패턴과 메서드와 필드를 구현하면서 선택한 결정에 영원히 책임을 져야한다. 그러니 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.
3. **생성자에서는 재정의 가능한 메서드를 호출하지 말라.**
    - 상위 클래스의 생성자가 실행되는 동안에는 하위 클래스의 필드가 아직 초기화되지 않은 상태일 수 있다. 이때 재정의된 메서드가 호출되면, 해당 메서드가 하위 클래스의 필드를 사용하려 할 때 `NullPointerException` 등이 발생할 수 있다.
4. **`clone`과 `readObject`에서도 재정의 가능한 메서드를 호출하지 말라.**
    - 이 메서드들도 내부적으로 재정의 가능한 메서드를 호출하면 안 된다. 객체를 만드는 역할을 하므로 생성자와 같은 위험을 가지고 있다.
5. **상속 대신 다른 대안을 고려하라.**
    - 상속용으로 설계되지 않은 클래스의 경우 상속을 금지하거나, 복잡한 상속 대신 래퍼 클래스 패턴을 대안으로 이용하는 방법이 있다.

---

### 3. 상속을 금지하는 방법

클래스가 상속용으로 설계되지 않았다면 상속을 명시적으로 금지해야 한다.

1. **`final` 클래스로 선언한다.**
    - 가장 간단하고 확실한 방법이다.
2. **모든 생성자를 `private`이나 `package-private`으로 선언한다.**
    - 외부에서 생성자를 호출할 수 없으므로 상속이 불가능해진다. 대신 public 정적 팩터리 메서드를 만들어 주는 방법이 있다.

---

### 요약

- 상속용 클래스는 내부 구현의 동작 방식과 재정의 가능한 메서드의 자기 사용 여부를 **`@implSpec`** 태그를 사용해 **반드시 문서화**해야 한다. 또 문서화한 것은 반드시 지켜야 한다.
- 따라서 상속용으로 클래스를 설계하지 않았다면 **`final` 키워드를 사용해 상속을 금지**하는 것이 더 좋을 수도 있다.
