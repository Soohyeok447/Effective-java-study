## Item 32: 제네릭과 가변인수를 함께 쓸 때는 신중하라

**가변인수(varargs)**는 메서드에 넘기는 인수의 개수를 동적으로 정할 수 있는 좋은 기능이지만 **제네릭**과 함께 사용하면 타입 안전성이 깨질 수 있다. 이 둘을 함께 사용하려면 컴파일러가 보내주는 경고의 의미를 정확히 이해하고 대처해야 한다.

---

### 1. 힙 오염

**힙 오염**은 매개변수화 타입의 변수가 **자신이 가리키지 않는 다른 타입의 객체**를 참조하게 되는 상황을 말한다. 이런 경우 `ClassCastException`이 발생할 수 있다.

가변인수 메서드는 내부적으로 인수를 담을 **배열**을 생성한다. 그런데 제네릭 타입의 배열은 타입 안전하지 않다(Item 28). `List<String>` 같은 제네릭 타입의 배열을 만들 수 없어서 가변인수 메서드는 실체화 불가 타입으로 배열을 만들게 되고 이것이 힙 오염의 원인이 된다.

**힙 오염 발생**

```java
static void dangerous(List<String>... stringLists) {
    List<Integer> intList = List.of(42);
    Object[] objects = stringLists;
    objects[0] = intList; // stringLists[0]에 intList를 할당 -> 힙 오염 발생
    String s = stringLists[0].get(0); // ClassCastException 발생
}
```

`stringLists`는 `List<String>[]` 타입이지만, 내부적으로는 `Object[]`처럼 취급된다. 따라서 `List<Integer>` 타입의 객체를 배열의 첫 번째 원소로 넣는 것이 가능해지고 결국 다른 곳에서 값을 꺼내 쓸 때 `ClassCastException`이 발생한다.

---

### 2. `@SafeVarargs` 애너테이션

자바 7부터 **`@SafeVarargs`** 애너테이션이 도입되었다. 이 애너테이션은 제네릭 가변인수 메서드 작성자가 "이 메서드는 타입 안전합니다"라고 **직접 보증**하는 역할을 한다. 컴파일러는 이 애너테이션이 달린 메서드의 비검사 경고를 더 이상 보내지 않는다.

**`@SafeVarargs`를 사용할 수 있는 경우:**

메서드가 타입 안전하다고 확신할 수 있을 때만 `@SafeVarargs`를 사용해야 한다. 다음 두 가지 조건을 만족해야 한다.

1. 메서드가 가변인수 배열(`E...` 타입의 배열)에 **어떤 값도 저장하지 않는다.**
    - 배열에 값을 저장하는 순간 힙 오염의 위험이 생긴다.
2. 가변인수 배열의 참조가 **외부로 유출되지 않는다.** (신뢰할 수 없는 코드에게 노출되지 않는다)
    - 배열의 내용을 읽기만 하는 것은 안전하다.

**안전한 사용 예시**:

`Arrays.asList(T... a)`는 받은 인수들로 리스트를 만드는 역할을 할 뿐이고 내부 배열을 수정하거나 외부로 노출하지 않으므로 타입 안전하다.

```java
@SafeVarargs
@SuppressWarnings("varargs")
public static <T> List<T> asList(T... a) {
    return new ArrayList<>(a);
}
```

---

### 3. 가변인수 대신 `List` 사용하기

`@SafeVarargs` 애너테이션을 통해 경고를 숨기는 것이 찝찝하면 더 안전하고 근본적인 해결책이 있다. 바로 **가변인수 대신 `List`를 사용하는 것**이다.

**`List`를 사용한 메서드**

```java
// 가변인수를 사용한 위험한 메서드
static <T> T[] toArray(T... args) { ... }

// List를 사용한 안전한 메서드
static <T> T[] toArray(List<T> args) { ... }
```

`List`를 사용하면 컴파일러가 타입 안전성을 완벽하게 보장해줄 수 있다. `List.of` 정적 팩터리 메서드를 사용하면 클라이언트 코드도 크게 복잡해지지 않는다.

---

### 요약

- 가변인수와 제네릭을 함께 사용하면 타입 안전성이 깨질 수 있고, 컴파일러가 비검사 경고를 보낸다.
- 제네릭 가변인수 메서드가 타입 안전하다고 **100% 확신**할 수 있을 때만 **`@SafeVarargs`** 애너테이션을 달아 경고를 숨겨라.
- `@SafeVarargs`를 사용할지 판단이 어렵다면, 메서드의 매개변수를 가변인수(`T...`) 대신 `List<T>`로 바꾸는 것이 가장 좋은 방법이다.
