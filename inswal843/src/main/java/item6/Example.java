package item6;

public class Example {

    // item 6 : 불필요한 객체 생성을 피하라

//    ## 불변 객체를 사용하는 방법
//    같은 기능을 하는 객체를 매번 생성하면 비효율적 이므로 하나를 재사용하는 편이 나을 때가 많다.
//    특히, String과 같은 불변 객체(아이템 17)는 언제든 재사용할 수 있다.

//    String s = new String("java");
//    생성자로 String을 만들면 이미 스트링 상수 풀에 같은 인스턴스가 있어도 새로운 인스턴스를 생성한다.

//    String s = "java";
//    이렇게 가져오면 스트링 상수 풀을 확인하고 이미 있는 인스턴스이면 새로 만들지 않고 하나의 인스턴스를 사용한다.


//    ## 생성자 대신 정적 팩터리 메서드를 사용하는 방법
//    생성자대신 정적 팩터리 메서드(아이템 1)를 제공하는 불변 클래스에서는
//    정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다.

//    Boolean(String) 생성자 대신 Boolean.valueOf(String) 팩터리 매서드를 사용하면
//    호출할 때마다 새로운 객체를 생성하지 않아서 불필요한 객체 생성을 피할 수 있다.


//    ## 생성 비용이 비싼 객체를 캐싱후 재사용
//    생성 비용이 비싼 객체가 반복해서 필요하다면 캐싱하여 재사용하는게 좋다.

//    문자열이 유효한지 확인하는 가장 간단한 방법인 String의 matches를 이용하는 방법이다.
//    static boolean isRomanNumeralSlow(String s) {
//        return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
//                + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
//    }
//    위 방법의 단점은 matches를 사용한다는 것이다.
//    matches는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만,
//    성능이 중요한 상황에서 반복해 사용하기 적합하지 않다.
//    이 메서드가 내부에서 만드는 정규 표현식용 Pattern 인스턴스는 한 번 쓰고 버려저서
//    곧바로 가비지 컬렉션 대상이 된다.
//    Pattern은 입력받은 정규표현식에 해당하는 유한 상태 머신을 만들기 때문에 생성비용이 높다.

//    public class RomanNumerals {
//        private static final Pattern ROMAN = Pattern.compile(
//                "^(?=.)M*(C[MD]|D?C{0,3})"
//                        + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
//
//        static boolean isRomanNumeralFast(String s) {
//            return ROMAN.matcher(s).matches();
//        }
//    }
//    성능을 개선하려면 필요한 정규표현식을 표현하는 (불변인) Pattern 인스턴스를 클래스 초기화(정적 초기화) 과정에서
//    직접 생성해 캐싱해두고, 나중에 isRomanNumeral이 호출될 때마다 이를 재사용한다.
//    이 개선된 방식은 성능 뿐만 아니라 코드도 더 명확해 졌다는 장점이 있다.

//    하지만 isRomanNumeralFast 이 한번도 사용되지 않아도 ROMAN이 초기화되어 비효율적이라 생각할 수 있다.
//    지연 초기화(아이템 83)을 통해 불필요한 초기화를 없애는 것도 가능하지만 코드만 복잡해지고 성능은 크게 개선되지 않다 추천하지 않는다.


//    ## 어댑터
//    객체가 불변이라면 재사용해도 안전함이 명백하다.
//    하지만 어댑터(뷰 라고도 한다)처럼 덜 명확하거나 직관에 반대되는 상황도 있다.
//    어댑터는 실제 작업은 뒷단 객체에 위임하고 자신은 인터페이스 역할을 해주는 객체다.
//    따라서 여러개를 만들 필요 없이 뒷단 객체 하나당 어댑터 하나씩만 만들어지면 충분하다.


//    ## 오토박싱
//    오토바싱은 기본타입과 박싱된 기본타입을 섞어 쓸 때 자동으로 상호 변환해주는 기술이다.
//    기본타입과 대응하는 박싱타입의 구분을 흐려주지만 완전히 없애주는 것은 아니다.
//    의미상으로 비슷해 보이지만 성능에서는 그렇지 않다(아이템 61).

//    private static long sum() {
//        Long sum = 0L;
//        for(long i=0; i<=Integer.MAX_VALUE; i++)
//            sum += i;
//
//        return sum;
//    }
//    모든 양의 정수의 총합을 계산하는 메서드로 int는 충분히 크지 않으니 long을 사용해 계산하고 있다.
//    답은 제대로 내지만 sum 변수를 long이 아닌 Long으로 선언해서 불필요한 Long 인스턴스가 약 2의 31승개나 만들어졌다.
//    Long으로 선언된 sum 변수를 long으로 바꾸면 10배 이상 빨라진다.
//    따라서 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.


//    ## 오해 방지
//    이번 아이템을 "객체 생성은 비싸니 피해야 한다"로 오해하면 안 된다.
//    특히나 요즘의 JVM에서는 별다른 일을 하지 않는 작은 객체를 생성하고 회수하는 일이 크게 부담되지 않는다.
//    프로그램의 명확성, 간결성, 기능을 위해 객체를 추가로 생성하는 것이라면 일반적으로 좋은 일이다.

//    단순히 객체 생성을 피하고자 자신만의 객체 풀(pool)을 만들지는 말자.
//    일반적으로 자체 객체 풀은 코드를 헷갈리게 만들고 메모리 사용량을 늘리고 성능을 떨어뜨린다.
//    요즘 JVM의 GC는 상당히 잘 최적화 되어서, 가벼운 객체를 다룰 때는 직접 만든 객체 풀보다 훨씬 빠르다.


//    이번 아이템은 방버적 복사를 다루는 아이템 50과 대조적이다.
//    둘다 잘 공부하고 상황에 맞는 방법을 사용하는 것이 중요하다고 생각한다.

}
