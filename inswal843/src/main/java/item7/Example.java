package item7;

public class Example {

    // item 7 : 다 쓴 객체 참조를 해제하라

//    C, C++과 달리 Java는 GC가 다 쓴 객체를 회수해 가니 매우 좋아보인다.
//    그렇다고 메모리 관리에 더 이상 신경 쓰지 않아도 된다고 오애하면 **절대** 안된다.

//    public class Stack {
//        private Object[] elements;
//        private int size = 0;
//        private static final int DEFAULT_INITIAL_CAPACITY = 16;
//
//        public Stack() {
//            elements = new Object[DEFAULT_INITIAL_CAPACITY];
//        }
//
//        public void push(Object e) {
//            ensureCapacity();
//            elements[size++] = e;
//        }
//
//        public Object pop() {
//            if (size == 0)
//                throw new EmptyStackException();
//            return elements[--size];
//        }
//
//        /**
//         * 원소를 위한 공간을 적어도 하나 이상 확보한다.
//         * 배열 크기를 늘려야 할 때마다 대략 두 배씩 늘린다.
//         */
//        private void ensureCapacity() {
//            if (elements.length == size)
//                elements = Arrays.copyOf(elements, 2 * size + 1);
//        }
//    }

//    위는 간단하게 스택을 구현한 코드이다.
//    특별한 문제는 없어 보이지만 매우 심각한 **메모리 누수** 문제가 있다.
//    오래 사용을 하면 할 수록 점점 GC의 활동과 메모리 사용량이 늘어나 성능이 저하된다.

//    메모리 누수가 일어나는 이유는 스택이 커졌다가 줄어들었을 때 스택에서 꺼내진 객체들을
//    가비지 컬렉터가 회수하지 않기 때문이다.
//    이 스택이 그 객체들의 다 쓴 참조(obsolete reference)를 여전히 가지고 있기 때문이다.
//    다 쓴 참조란 앞으로 다시 쓰지 않을 참조를 뜻하고 코드의 elements 배열 밖의 참조들이 모두 해당한다.

//    GC는 객체 참조를 하나 살려두면 그 객체 뿐만 아니라 그 객체가 참조하는 모든 객체를 회수하지 못한다.
//    따라서 해법은 해당 참조를 다 사용했을 때 null 처리(참조 해제)하면 된다.
//    public Object pop() {
//        if (size == 0)
//            throw new EmptyStackException();
//        Object result = elements[--size];
//        elements[size] = null; // 다 쓴 참조 해제
//        return result;
//    }
//    사용이 끝난 시점에서 null처리 해주면 다른 이점도 있다.
//    null 처리한 참조를 실수로 사리 사용하려고 하면 NPE를 던지며 프로그램이 종료되어 오류를 발견하기 쉽다.


//    ## 그럼 항상 null 처리를 해줘야 할까?
//    그렇다고 필요 없는 객체를 볼 때마다 null 처리하면, 오히려 프로그램을 필요 이상으로 지저분하게 만든다.
//    객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.
//    다 쓴 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효범위(scope) 밖으로 밀어내는 것이다. <- 무슨 의미지?
//    변수의 범위를 가능한 최소가 되게 정의했다면(item 57) 이 일은 자연스럽게 이뤄진다.


//    ## 그럼 언제 null 처리를 하는게 좋을까?
//    일반적으로 **자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수를 주의해야 한다.**
//    위 예시의 스택 코드가 바로 그런 경우이다. elememts 배열로 저장소 풀을 만들어 원소들을 관리한다.
//    GC는 활성 영역과 비활성 영역은 쓰이지 않는다는 사실을 알 길이 없다.
//    따라서 더이상 쓰이지 않는 참조는 프로그래머가 명시적으로 null 처리를 해주어야 GC가 처리를 해주어서
//    메모리 누수가 발생하지 않는다.


//    ## 캐시 역시 메모리 누수의 주범
//    객체 참조를 캐시에 넣고 나서, 이 사실을 잊으면 그 객체는 GC의 회수 대상이 되지 않는다.
//    캐시 외부에서 키(key)를 참조하는 동안만(값이 아니다) 엔트리가 살아있는 캐시가 필요한 상황이라면
//    WeakHashMap을 사용해 캐시를 만들자. 이러면 다 쓴 엔트리는 그 즉시 자동으로 제거될 것이다.

//    캐시를 만들 때 보통은 캐시 엔트리의 휴요기간을 정확히 정의하기 어렵기 때문에
//    시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식을 사용한다.
//    이런 방식에선 쓰지 않는 엔트리를 백그라운드 스레드를 활용하거나 새 엔트리를 추가할때 부수 작업을 추가하는 방식으로
//    제거하는 작업을 수행해 주어야 한다.


//    ## 리스너, 콜백도 메모리 누수의 주범
//    클라이언트가 콜백을 등록만 하고 명확히 해지하지 않으면 뭔가 조치를 취해주지 않는 이상 콜백을 계속 쌓인다.
//    이럴때 콜백을 약한 참조(weak reference)로 저장하면 GC가 즉시 수거해 간다. ex) WeakHashMap에 키로 저장


//    ## 핵심 정리
//    메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 있다.
//    이런 누수는 철저한 코드 리뷰나 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견되기도 한다.
//    그래서 이런 종류의 문제는 예방법을 익혀두는 것이 매우 중요하다.


}


































