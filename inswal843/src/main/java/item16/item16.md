## Item 16: public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

클래스의 필드에 직접 접근하게 하면 캡슐화의 이점을 잃게 된다. 외부에서 필드에 직접 접근할 수 있으면 클래스 내부의 표현 방식을 바꿀 유연성을 잃고 불변식을 보장할 수 없게 된다.

---

### 1. public 필드의 문제점

- **API를 변경할 수 없다:** 공개된 필드는 다른 API의 일부가 된다. 만약 필드의 타입을 바꾸거나 제거하는 경우 해당 필드를 사용하던 모든 클라이언트 코드가 깨진다.
- **불변식을 보장할 수 없다:** 외부에서 필드 값을 마음대로 바꿀 수 있으므로 클래스가 의도한 상태(예: 나이는 항상 양수)를 유지할 수 없다. 즉, 유효성 검사를 수행할 공간이 없다.
- **부가 작업을 할 수 없다:** 필드에 접근할 때 특정 로직(로깅, 이벤트 등)을 수행하고 싶어도 직접 접근 방식에서는 불가능하다.

**나쁜 예시: public 필드를 가진 클래스**

```java
class Point {
    public double x;
    public double y;
}
```

이 Point 클래스는 내부 표현을 바꾸거나, x와 y 값에 대한 제약을 가할 수 없다. 캡슐화가 완전히 깨진 상태다.

---

### 2. 접근자와 변경자(Mutator) 메서드

이 문제를 해결하기 위해 필드를 모두 private으로 바꾸고 값을 읽고 쓸 수 있는 public 메서드, 즉 **접근자(getter)와 변경자(setter)**를 제공하는 방법이 있다.

**좋은 예시: 접근자와 변경자를 사용하는 클래스**

```java
class Point {
    private double x;
    private double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    public void setX(double x) {
        // setter에서 유효성 검사나 다른 로직을 추가할 수 있다.
        this.x = x;
    }

    public void setY(double y) {
        this.y = y;
    }
}
```

**장점:**

- **내부 표현 변경의 유연성:** private 필드이므로 나중에 내부 자료구조를 바꿔도(예: 변수명 변경 등), getter/setter의 시그니처만 유지하면 외부에 아무런 영향을 주지 않는다.
- **불변식 보장:** setter 메서드 내부에서 인자의 유효성을 검사하여 클래스의 일관성을 유지할 수 있다.
- **부가 작업 가능:** getter나 setter가 호출될 때 로깅, 이벤트 등 다양한 추가 동작을 수행할 수 있다.
- **읽기 전용 필드:** setter를 제공하지 않으면 해당 필드를 **읽기 전용**으로 만들 수 있다.

---

### 3. package-private 클래스와 private 중첩 클래스

클래스가 **package-private**이거나 **private 중첩 클래스**라면 데이터 필드를 노출해도 큰 문제가 되지 않는다. 그 클래스가 표현하려는 추상 개념만 올바르게 표현해 주면 된다. 이 방식이 선언 면에서나 사용하는 클라이언트 면에서나 접근자 방식보다 훨씬 깔끔하다. 클래스의 사용 범위가 패키지 내부나 외부 클래스로 한정되어 있어, 내부 구현을 변경하더라도 수정 범위가 명확하고 통제 가능하기 때문이다.

---

### 최종 요약

- **public 클래스는 절대 데이터 필드를 직접 노출해서는 안 된다.** 필드를 private으로 선언하고 public 접근자(getter)를 제공해라. 가변 필드라면 변경자(setter)도 제공할 수 있다.
- **package-private**이거나 **private 중첩 클래스**에서는 종종 필드를 노출하는 편이 나을 때도 있다.
- 이 지침을 통해 클래스는 **캡슐화**의 장점과 함께 유연하고 견고한 코드를 작성할 수 있게 된다.
