## Item 28: 배열보다는 리스트를 사용하라

배열과 제네릭 타입(리스트 등)은 몇 가지 중요한 차이점이 있다. 핵심은 **배열은 공변(covariant)**이고 **제네릭은 불공변**이라는 것이다. 이 차이 때문에 배열은 런타임에 타입 문제가 발생할 수 있지만 리스트는 컴파일 타임에 문제를 잡아낼 수 있다. 따라서 더 안전한 코드를 위해 **배열보다는 리스트를 사용하는 것이 좋다.**

---

### 1. 공변 vs 불공변

- **공변 (배열):** `Sub`가 `Super`의 하위 타입이라면, 배열 `Sub[]`는 `Super[]`의 하위 타입이다. 따라서 `Super[]` 타입의 변수에 `Sub[]` 타입의 배열을 할당할 수 있다.
- **불공변 (리스트):** `Sub`가 `Super`의 하위 타입이라도, `List<Sub>`는 `List<Super>`의 하위 타입이 **아니다.** 서로 다른 타입으로 취급된다.

**배열의 공변성**

```java
// 1. 컴파일 시점에는 문제가 없다. (공변)
Object[] objectArray = new Long[1];

// 2. 런타임에 ArrayStoreException 발생!
// Long의 배열에 String을 넣으려고 시도한다.
objectArray[0] = "타입이 달라요";
```

이처럼 배열은 컴파일러가 타입 문제를 잡지 못하고, 실행을 해봐야만 오류를 알 수 있다.

**리스트의 불공변성**

```java
// 1. 컴파일 오류 발생! (불공변)
// List<Long>은 List<Object>의 하위 타입이 아니다.
List<Object> ol = new ArrayList<Long>();

// 2. 따라서 잘못된 타입의 원소를 넣으려는 시도를 미리 차단한다.
ol.add("타입이 달라요");
```

리스트를 사용하면 이와 같은 타입 불일치 문제를 **컴파일 시점**에 발견하고 수정할 수 있다. **런타임 오류보다 컴파일 오류가 훨씬 더 좋다.**

---

### 2. 제네릭 배열을 만들 수 없는 이유

자바에서는 `new List<E>[]`, `new List<String>[]`, `new E[]` 와 같은 **제네릭 배열을 생성할 수 없다.** 타입 안전성을 보장할 수 없기 때문이다. 만약 제네릭 배열 생성이 가능하다면 컴파일러의 타입 체크를 우회하여 런타임에 `ClassCastException`을 발생시키는 코드를 쉽게 만들 수 있다.

```java
// 제네릭 배열 생성이 허용된다고 가정해보자 (실제로는 불가능)
List<String>[] stringLists = new List<String>[1];   // 1
List<Integer> intList = List.of(42);                // 2
Object[] objects = stringLists;                     // 3
objects[0] = intList;                               // 4
String s = stringLists[0].get(0);                   // 5 ClassCastException 발생!
```

위 코드의 5번 줄에서 `Integer`를 `String`으로 바꾸려다 오류가 발생한다. 이런 타입 문제를 막기 위해 자바는 애초에 1번 줄에서 제네릭 배열 생성을 금지한다.

---

### 3. 배열에서 리스트로 전환

배열이 필요한 API와 제네릭 코드를 함께 사용해야 할 때 타입 안전성 문제가 발생할 수 있다. 제네릭 클래스 내부에서는 배열을 사용하지 말고 가능한 한 리스트로 대체하는 것이 좋다.

- **제네릭 타입(`E`)의 배열을 만들고 싶을 때:**
    - `E[]` 대신 `List<E>`를 사용하라.
    - 성능이 살짝 나빠질 수도 있지만 **타입 안전성**과 **상호 운용성**으로 얻는 이점이 훨씬 크다.
- **배열을 사용해야만 한다면:**
    - `E[]` 대신 `Object[]` 배열을 생성하고 원소를 꺼낼 때 `(E)`로 형변환해주는 방법을 사용할 수 있다. 해당 코드가 타입에서 안전함을 확신한다면 애너테이션을 달아 경고를 숨겨도 된다. 하지만 애초에 **경고의 원인을 제거하는 편이 훨씬 낫다**(item 27).

---

### 요약

- 배열은 **공변**이고 **실체화**되는 반면, 제네릭은 **불공변**이고 타입 정보가 **소거**된다.
- 이러한 차이 때문에 배열은 런타임 오류에 취약하고 리스트는 컴파일 타임에 타입 안전성을 보장한다.
- **배열과 제네릭을 섞어 쓰면 타입 안전성이 깨지기 쉬워서 일반적으로 배열보다는 리스트를 사용하는 것이 훨씬 더 안전하고 좋다.**
