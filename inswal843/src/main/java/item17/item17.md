## Item 17: 변경 가능성을 최소화하라

- **불변 클래스**란 그 인스턴스의 내부 값을 수정할 수 없는 클래스다. **불변 인스턴스**는 생성된 시점의 상태를 객체가 파괴될 때까지 그대로 간직한다. 자바 라이브러리에는 **String**, 기본 타입의 박싱된 클래스(**Integer, Long** 등), **BigInteger, BigDecimal** 등이 대표적인 불변 클래스다.

불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.

---

### 1. 불변 클래스를 만드는 다섯 가지 규칙

1. **객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.**
    - `setter` 같이 필드 값을 수정하는 메서드를 만들지 않는다.
2. **클래스를 확장할 수 없도록 한다.**
    - `final` 클래스로 선언하여 상속을 막는다. 상속을 허용하면 하위 클래스에서 가변 객체를 만들어 불변성을 깨뜨릴 수 있다.
3. **모든 필드를 `final`로 선언한다.**
    - 필드에 값이 한 번 할당되면 다시는 수정할 수 없음을 명확히 하기위해 시스템의 도움을 받는다.
4. **모든 필드를 `private`으로 선언한다.**
    - 클라이언트가 필드에 직접 접근하여 수정하는 것을 막는다. `public final` 필드라도 참조하는 객체가 가변이라면 불변성이 깨진다.
5. **자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.**
    - 클래스가 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트가 그 객체의 참조를 얻지 못하도록 해야 한다. 생성자, 접근자(getter) 등에서 **방어적 복사**를 수행하여 내부 객체의 참조가 외부로 유출되지 않도록 막아야 한다.

**예시**

```java
public final class Complex {
    private final double re;
    private final double im;

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    // 접근자(getter)
    public double realPart() {
        return re;
    }
    public double imaginaryPart() {
        return im;
    }

    // 연산 메서드는 새로운 인스턴스를 반환한다. (함수형 프로그래밍)
    public Complex plus(Complex c) {
        return new Complex(re + c.re, im + c.im);
    }

    public Complex minus(Complex c) {
        return new Complex(re - c.re, im - c.im);
    }
    
    public Complex times(Complex c) {
        return new Complex(re * c.re - im * c.im,
									         re * c.im + im * c.re);
    }
    
    // equals, hashCode, toString ...
}
```

`plus`, `minus` 같은 연산 메서드가 `this`를 수정하지 않고 새로운 `Complex` 인스턴스를 만들어 반환하는 점에 주목하자. 이것을 **함수형 프로그래밍**이라 하며 상태를 변경하지 않고 항상 새로운 값을 만들어 반환하는 패턴이다.

---

### 2. 불변 클래스의 장점, 단점

### 장점

1. **단순하다:** 불변 객체는 생성된 이후 상태가 변하지 않으므로 메서드가 일으키는 상태 전이를 추적할 필요가 없어 믿고 코드를 작성하는게 가능해진다.
2. **근본적으로 스레드 안전하다:** 상태가 변하지 않으므로 여러 스레드가 동시에 접근해도 데이터가 훼손될 걱정이 없다. **동기화**가 전혀 필요 없다.
3. **자유롭게 공유할 수 있고, 불변 객체 끼리는 내부 데이터를 공유할 수 있다**.
4. **불변 객체를 구성요소로 사용하면 이점이 많다**: 값이 바뀌지 않는 구성요소로 이루어진 객체라면 구조가 아무리 복잡해도 불변식을 유지하기 훨씬 수월하기 때문이다.
5. **실패 원자성(failure atomicity)을 제공한다(item 76):** 상태가 절대 변하지 않으므로 잠깐이라도 불일치 상태에 빠질 가능성이 없다.

### 단점

- **값이 다르면 반드시 독립된 객체로 만들어야 한다:** 값의 종류가 많거나 객체가 크다면, 새로운 객체를 계속 생성하는 것이 메모리나 성능에 부담을 줄 수 있다. (백만 비트짜리 `BigInteger`에서 비트 하나를 바꾸기 위해 새로운 `BigInteger`를 생성해야 함)

---

### 3. 단점 해결책

불변 클래스와 쌍을 이루는 **가변 동반 클래스(companion class)**를 제공하는 것이 좋은 해결책이다.

- `String`(불변)과 `StringBuilder`(가변 동반 클래스)
- `BigInteger`(불변)과 `BitSet`(가변 동반 클래스)

클라이언트는 여러 단계의 복잡한 연산을 가변 동반 클래스로 효율적으로 처리한 뒤, 마지막에 그 결과를 바탕으로 불변 클래스의 인스턴스를 생성할 수 있다.

---

### 요약

- 클래스는 꼭 필요한 경우가 아니라면 **불변으로 만들어라.**
- 불변으로 만들 수 없다면, **변경 가능성을 최대한 제한하라.**
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.
- 성능 때문에 어쩔 수 없다면, 불변 클래스와 함께 **가변 동반 클래스**를 제공하는 것을 고려하라.
